<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content=""/>
  
  <title>浅析JVM内存区域 | 淘淘的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java虚拟机在执行java程序的时候，会把它所管理的内存划分为若干不同的数据区。这些区域有的随着java进程的启动而生成，有的随着线程的启动和结束而创建和销毁。">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析JVM内存区域">
<meta property="og:url" content="http://tonylit.me/2016/11/21/浅析jvm内存区域/index.html">
<meta property="og:site_name" content="淘淘的博客">
<meta property="og:description" content="Java虚拟机在执行java程序的时候，会把它所管理的内存划分为若干不同的数据区。这些区域有的随着java进程的启动而生成，有的随着线程的启动和结束而创建和销毁。">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/JVM结构图.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/栈帧结构.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/stackframe.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/StackOverflowError.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/stackoom.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/jvm堆内存结构.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/survivor.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/heapoomtest.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/permoom.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/cgliboom.PNG">
<meta property="og:image" content="http://tonylit.me/img/jvm/memory_area/jvm内存区域图.PNG">
<meta property="og:updated_time" content="2016-11-21T05:37:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析JVM内存区域">
<meta name="twitter:description" content="Java虚拟机在执行java程序的时候，会把它所管理的内存划分为若干不同的数据区。这些区域有的随着java进程的启动而生成，有的随着线程的启动和结束而创建和销毁。">
  
    <link rel="alternative" href="/atom.xml" title="淘淘的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/leaves.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
  <script src="http://tonylit.me//js/jquery.nicescroll.js"></script>

</head>

<body>

  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
<form class="search" method="get" accept-charset="utf-8">
			<input type="text" id="chillax-search-input" class="st-search-input_my" maxlength="30" placeholder="search" />
		</form>


	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/c.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/" class="alluraregular">tonyli</a></h1>
		</hgroup>
        <!--
		
		<p class="header-subtitle">今年lebron绝逼夺冠，bie跟我急!</p>
		
        -->
		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>

				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/work">工作日志</a></li>
				        
							<li><a href="/tags/life">点滴生活</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/tonylit" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2136920064/profile?topnav=1&wvr=6" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-tao-40-20-98" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>

				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Gatling/" style="font-size: 11.67px;">Gatling</a> <a href="/tags/Jmeter/" style="font-size: 11.67px;">Jmeter</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/apache/" style="font-size: 10px;">apache</a> <a href="/tags/atom/" style="font-size: 10px;">atom</a> <a href="/tags/docker/" style="font-size: 18.33px;">docker</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/kafka/" style="font-size: 11.67px;">kafka</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/loadrunner/" style="font-size: 13.33px;">loadrunner</a> <a href="/tags/nGrinder/" style="font-size: 10px;">nGrinder</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a> <a href="/tags/springmvc/" style="font-size: 10px;">springmvc</a> <a href="/tags/work/" style="font-size: 16.67px;">work</a> <a href="/tags/前端性能/" style="font-size: 10px;">前端性能</a> <a href="/tags/性能/" style="font-size: 20px;">性能</a>
					</div>
				</section>
				

				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">科比：他来湖人.或者我去骑士.就这么简单 麦迪：我希望更正一下我之前说的话.如果詹姆斯是我的队友... 凯文杜兰特：我永远在追赶他的背影 保罗：我人生最大的两个愿望.一是为基德打替补.二是为詹姆斯奉献助攻 艾弗森：他才是答案。 迈克尔.乔丹：我很幸运，当他进入NBA的时候，我已经退役了！</div>
				</section>
				
			</div>
		</div>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">tonyli</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/c.jpg" class="js-avatar">
				<hgroup>
				  <h1 class="header-author">tonyli</h1>
				</hgroup>
			</div>
			
			<p class="header-subtitle">今年lebron绝逼夺冠，bie跟我急!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/work">工作日志</a></li>
		        
					<li><a href="/tags/life">点滴生活</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/tonylit" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2136920064/profile?topnav=1&wvr=6" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-tao-40-20-98" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>
	</div>
</nav>

	  <div class="recent">
高手的存在，就是让服务10亿人的时候，你感觉只是为你一个人服务......
</div>

      <div class="body-wrap"><article id="post-浅析jvm内存区域" class="article article-type-post" itemscope itemprop="blogPost">
    <script>
        $("html").niceScroll({
            cursorcolor: "#2a2929",
            cursoropacitymax: 1,
            touchbehavior: false,
            cursorwidth: "6px",
            cursorborder: "5",
            cursorborderradius: "0px",
            autohidemode: true
        });
    </script>
    
        <div class="article-meta">
            <a href="/2016/11/21/浅析jvm内存区域/" class="article-date">
  	<time datetime="2016-11-21T03:37:27.000Z" itemprop="datePublished">2016-11-21</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      浅析JVM内存区域
    </h1>
  


                            </header>
                            
                                <div class="article-info article-info-post">
                                    
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>


                                        

                                            <div class="clearfix"></div>
                                </div>
                                
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                                    <!--02-->
                                                    <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#程序计数器（Program_Counter_Register）"><span class="toc-number">1.</span> <span class="toc-text">程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java虚拟机栈（VM_Stack）"><span class="toc-number">2.</span> <span class="toc-text">java虚拟机栈（VM Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java虚拟机栈内存溢出"><span class="toc-number">2.1.</span> <span class="toc-text">java虚拟机栈内存溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#本地方法栈（Native_Method_Stack）"><span class="toc-number">3.</span> <span class="toc-text">本地方法栈（Native Method Stack）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java堆（heap区）"><span class="toc-number">4.</span> <span class="toc-text">java堆（heap区）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个对象的一生"><span class="toc-number">4.1.</span> <span class="toc-text">一个对象的一生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java堆内存溢出"><span class="toc-number">4.2.</span> <span class="toc-text">java堆内存溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法区（Method_Area）"><span class="toc-number">5.</span> <span class="toc-text">方法区（Method Area）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池（Runtime_Constant_Pool）"><span class="toc-number">5.1.</span> <span class="toc-text">运行时常量池（Runtime Constant Pool）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区内存溢出"><span class="toc-number">5.2.</span> <span class="toc-text">方法区内存溢出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#直接内存（Direct_Memory）"><span class="toc-number">6.</span> <span class="toc-text">直接内存（Direct Memory）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java虚拟机各内存区域图汇总"><span class="toc-number">7.</span> <span class="toc-text">java虚拟机各内存区域图汇总</span></a></li></ol>
</div>

                                                        
                                                            
                                                                
                                                                            <p>Java虚拟机在执行java程序的时候，会把它所管理的内存划分为若干不同的数据区。<br>这些区域有的随着java进程的启动而生成，有的随着线程的启动和结束而创建和销毁。</p>
<a id="more"></a>
<p>大多数 JVM 将内存区域划分为 <strong>Method Area（Non-Heap）（方法区）,Heap（堆）,Program Counter Register（程序计数器）, VM Stack（虚拟机栈，也有翻译成JAVA 方法栈）,Native Method Stack （本地方法栈）</strong>，<br>其中Method Area和Heap是线程共享的，VMStack，Native Method Stack 和Program Counter Register是线程私有的。<br><img src="/img/jvm/memory_area/JVM结构图.PNG" alt="Alt text"></p>
<p>概括地说来，JVM初始运行的时候都会分配好Method Area（方法区）和Heap（堆），<br>而JVM 每遇到一个线程，就为其分配一个Program Counter Register（程序计数器）, VM Stack（虚拟机栈）和Native Method Stack （本地方法栈），<br>当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。</p>
<p>方法区与堆这两块区域的内存清理通过垃圾收集器来回收。</p>
<hr>
<h1 id="程序计数器（Program_Counter_Register）">程序计数器（Program Counter Register）</h1><p>程序计数器是一块较小的内存空间，可以看做是<strong>当前线程执行的字节码的位置指示器</strong>。<br>分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。</p>
<p>为什么<strong>程序计数器是线程私有的</strong>呢？ 由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。<br>在任何一个时刻，一个处理器都只会处理一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器来保证各条线程之间的程序计数器互不影响，独立存储。</p>
<p>如果线程正在执行的是一个java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址。<br>如果正在执行的是Native方法，则计数器为空（Undefined）。</p>
<p>该内存区域是唯一一个在java虚拟机规范中没有规定任何OOM情况的区域。</p>
<hr>
<h1 id="java虚拟机栈（VM_Stack）">java虚拟机栈（VM Stack）</h1><p><strong>java虚拟机栈也是线程私有的</strong>，它的生命周期与线程相同，线程结束后栈内存也就释放了，所以对于<strong>java虚拟机栈来说不存在垃圾收集的问题</strong>。</p>
<p>有些资料把该区域翻译成java方法栈，大概是因为它所描述的是java方法执行的内存模型。<br>每个方法的执行，同时都会在虚拟机栈上创建一个栈帧（Stack Frame），用于存储<strong>局部变量表</strong>，操作栈（Operand Stack，记录出栈、入栈的操作），方法出口，动态链接等。<br><strong>每个方法被调用直到执行完毕的过程，对应这帧栈在虚拟机栈的入栈和出栈的过程</strong>。有时候方法的递归，会造成大量的栈帧，达到一定的深度，会报StackOverflowError异常。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double），对象的引用以及returnAddress类型（指向了一条字节码指令的地址）。<br><strong>有一点需要说明:在编译器编译Java代码时，就已经在字节码中为每个方法都设置好了局部变量区和操作数栈的数据和大小。</strong>并在JVM首次加载方法所属的Class文件时， 就将这些数据放进了Method Area（方法区），该局部变量表所需要的内存空间是固定的，运行期间也不会改变。<br>因此在线程调用方法时，只需要根据方法区中的局部变量区和操作数栈的大小来分配一个新的栈帧的内存大小，并堆入Java栈就可以了。<br><img src="/img/jvm/memory_area/栈帧结构.PNG" alt="Alt text"></p>
<p>栈帧是一个内存区块，是一个数据集（类似数据结构中的栈），是一个有关方法(Method)和运行期数据的数据集。<br>当一个方法 A 被调用时就产生了一个栈帧 F1，并被压入到栈中，A 方法又调用了 B 方法，于是产生栈帧 F2 也被压入栈，执行完毕后，先弹出 F2栈帧，再弹出 F1 栈帧，遵循“<strong>先进后出</strong>”原则<br>（对于“先进后出”，这里差个话题，<a href="https://www.zhihu.com/question/34499262/answer/59415153" target="_blank" rel="external">为什么函数调用要用栈实现？</a>，大R的回答）。<br><img src="/img/jvm/memory_area/stackframe.PNG" alt="Alt text"></p>
<p>java虚拟机栈可以动态的扩展，如果扩展时无法申请到足够的内存，则报OOM的错误。</p>
<h2 id="java虚拟机栈内存溢出">java虚拟机栈内存溢出</h2><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，则抛出StackOverFlowError异常。</p>
<p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
<p><strong>java虚拟机栈-StackOverFlowError异常测试代码</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * -Xss128k</span><br><span class="line"> * </span><br><span class="line"> * @author lit</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JavaStackOOMTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        JavaStackOOMTest oom = <span class="keyword">new</span> JavaStackOOMTest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/img/jvm/memory_area/StackOverflowError.PNG" alt="Alt text"></p>
<p>可以看到，我机器上128k的栈容量能承载深度为2401的方法调用。</p>
<p><strong>java虚拟机栈-OutOfMemoryError异常测试代码</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * -Xss1M</span><br><span class="line"> * </span><br><span class="line"> * @author lit</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger counter_integer = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dnotStop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        counter_integer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 一直创建线程</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">                @<span class="function">Override</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                    countThread();</span><br><span class="line"></span><br><span class="line">                    dnotStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        StackOOM oom = <span class="keyword">new</span> StackOOM();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeakByThread();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"====&gt;"</span> + counter_integer.<span class="keyword">get</span>());</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Xss可以设置大一些，很快就会报错</p>
</blockquote>
<p><strong>运行结果：</strong><br><img src="/img/jvm/memory_area/stackoom.PNG" alt="Alt text"></p>
<hr>
<h1 id="本地方法栈（Native_Method_Stack）">本地方法栈（Native Method Stack）</h1><p><strong>本地方法栈是线程私有的。</strong></p>
<p>与VM Strack相似，VM Strack为JVM提供执行JAVA方法的服务，Native Method Stack则为JVM提供使用native 方法的服务。它的实现比较自由，比如Hotspot把本地方法栈和java虚拟机栈合二为一了。</p>
<p>本地方法栈与java虚拟机栈一样，会报StackOverflowError与OOM异常。</p>
<hr>
<h1 id="java堆（heap区）">java堆（heap区）</h1><p>大多情况下，堆是jvm中最大的一块内存区域。</p>
<p><strong>java堆被所有线程共享</strong>，在虚拟机启动的时候创建，几乎所有的对象实例都在这里分配内存（TLAB与逃逸分析，在栈上分配内存）。</p>
<p>java堆是垃圾收集的主要区域，整个java堆可以细分为：<strong>新生代（eden区、Survivor区（s1、s0））和年老代</strong>。<br>现在的垃圾收集器基本都采用分代收集算法,根据不同代中对象的生命周期长短，采用不同的垃圾收集算法，可以扬长避短。<br><img src="/img/jvm/memory_area/jvm堆内存结构.PNG" alt="Alt text"></p>
<p><strong>Eden Space：</strong>大多情况下，对象在新生代eden区中分配内存（jvm提供了-XX：PretenureSizeThreshold参数，让大于这个值的对象直接进入年老代分配内存，避免eden和survivor区之间发生大量的内存复制）。</p>
<p><strong>Survivor Space</strong>:用于保存在eden区中经过垃圾回收后没有被回收的对象，也就是“幸存还活着”的对象。</p>
<blockquote>
<p>Survivor区分为两个相同大小的区域（s0,s1），<br>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。<br>紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。<br>年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。<br>经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。<br>不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br><img src="/img/jvm/memory_area/survivor.PNG" alt="Alt text"></p>
</blockquote>
<p><strong>Old Space</strong>:有些资料上也叫作Tenured区。对象经过survivor区，每经历过一次垃圾回收，年龄就增加1，超过设定阀值后，被移入年老代，当然也包括由于担保机制移入的对象。</p>
<p>年老代中对象的生命周期相对长一些，当年老代的内存使用到一定阀值的时候（或者晋升失败等其他触发major gc的情况），会触发年老代的垃圾回收，回收不用的对象。</p>
<p>java堆可以处于物理上不连续的内存空间中，只要逻辑上面是连续的即可。<br>堆的大小可以通过jvm参数扩展（-Xmx与-xms，一般情况设置为相同的值，避免堆自动扩展），如果对象的实例进入java堆时，没有足够的内存空间分配，同时堆也无法进行扩展，会报OOM异常。</p>
<h2 id="一个对象的一生">一个对象的一生</h2><p>我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。<br>有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。<br>直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了，于是我就去了年老代那边。年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了很多年，然后被回收。</p>
<h2 id="java堆内存溢出">java堆内存溢出</h2><p>java堆用于存储对象的实例，只要不断的去创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<p><strong>java堆OutOfMemoryError测试代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * VM Args:-Xmx10M -Xms10M -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> lit</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB];</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(allocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>XX:+HeapDumpOnOutOfMemoryError 参数可以在jvm出现内存溢出时dump出当前的内存堆快照。</p>
</blockquote>
<p><strong>运行结果：</strong><br><img src="/img/jvm/memory_area/heapoomtest.PNG" alt="Alt text"></p>
<p>OOM在实际的应用中非常常见，当出现java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示：“java heap space”表明是java堆的溢出。</p>
<hr>
<h1 id="方法区（Method_Area）">方法区（Method Area）</h1><p><strong>方法区和java堆一样，是线程共享的内存区域。</strong> 它用于存储已经被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。<br>为了跟java堆区分开来，它有一个别名叫做Non-Heap。对于HotSpot虚拟机来说，jdk1.8以前该区域经常也会被叫做永久代，<a href="http://www.infoq.com/cn/articles/Java-PERMGEN-Removed" target="_blank" rel="external">1.8以后永久代被取消</a>。</p>
<p>永久代可以使用-XX:MaxPermSize来扩展大小，垃圾回收在这个区域会比较少出现，这个区域内存回收的目的主要针对常量池的回收和类的卸载。<br>当方法区无法满足内存分配需求的时候，会报OOM异常。</p>
<h2 id="运行时常量池（Runtime_Constant_Pool）">运行时常量池（Runtime Constant Pool）</h2><p>运行时常量池是方法区中非常重要的一部分。在字节码文件（Class文件）中，除了有类的版本、字段、方法、接口等先关信息描述外，还有<a href="http://www.jianshu.com/p/c7f47de2ee80" target="_blank" rel="external">常量池（Constant Pool Table）信息</a>，用于存储编译器产生的字面量和符号引用。<br><strong>这部分内容在类被加载后，都会存储到方法区中的运行时常量池中</strong>。值得注意的是，运行时产生的新常量也可以被放入常量池中，比如 String 类中的 intern() 方法产生的常量（大量的使用会造成方法区OOM）。</p>
<h2 id="方法区内存溢出">方法区内存溢出</h2><p>这里使用String.intern()，它的作用是：如果字符串已经在方法区的常量池中，则返回代表池中这个字符串的String对象，否则会把字符串添加到常量池中。</p>
<p><strong>方法区OutOfMemoryError测试代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> * </span><br><span class="line"> * @author lit</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConstantOOM &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-XX:PermSize和-XX:MaxPermSize来限制方法区的大小</p>
</blockquote>
<p><strong>运行结果：</strong><br><img src="/img/jvm/memory_area/permoom.PNG" alt="Alt text"></p>
<p>方法区存放Class的相关信息，如类名、常量池、字段描述、方法描述等，如果不断的去产生大量的类，方法区也会溢出。<br>尤其是现在越来越多的框架,如Spring AOP、Hibernate等，在对类进行增强时，会使用CGLib这类字节码技术，来转换字节码并生成新的类，<br>所以在我们实际的工作中经常会碰到由此产生的“OutOfMemoryError: PermGen space”异常。</p>
<p><strong>（CGLib）方法区OutOfMemoryError测试代码：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> java.lang.reflect.Method;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span></span><br><span class="line"><span class="preprocessor"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class="line"> * </span><br><span class="line"> * @author lit</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMOjbect</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Enhancer eh = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            eh.setSuperclass(OOMOjbect.<span class="keyword">class</span>);</span><br><span class="line">            eh.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            eh.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                <span class="keyword">public</span> Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    <span class="keyword">return</span> arg3.invokeSuper(arg0, arg2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            eh.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/img/jvm/memory_area/cgliboom.PNG" alt="Alt text"></p>
<hr>
<h1 id="直接内存（Direct_Memory）">直接内存（Direct Memory）</h1><p>直接内存不是java虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。<br>该区域也会在 Java 开发中使用到，并且存在导致内存溢出的隐患。</p>
<p>如果你对 NIO 有所了解，可能会知道 NIO 是可以使用 Native Methods 来使用直接内存区的。<br>NIO是在JDK1.4以后新加入的类，基于通道（Channel）与缓冲区（Buffer）的I/0方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用来进行操作。<br>这样可以显著提高性能，避免java堆与native堆中来回复制数据。</p>
<p>直接内存不会受到java堆大小的限制，但是会受到本机总内存的大小和处理器寻址空间的限制。所以也可能出现oom的异常。</p>
<hr>
<h1 id="java虚拟机各内存区域图汇总">java虚拟机各内存区域图汇总</h1><p>通过上面的介绍，我们对JVM的内存区域有了一定的理解。JVM内存区域可以分为线程共享和线程私有两部分，线程共享的有堆和方法区，线程私有的有虚拟机栈，本地方法栈和程序计数器；另外，直接内存也是线程共享的。</p>
<p>除了程序计数器，其他区域都有出现OOM的情况。</p>
<p><img src="/img/jvm/memory_area/jvm内存区域图.PNG" alt="Alt text"></p>
<hr>

                                                                                
                                        </div>
                                        
            </div>
            
                <div class="bdsharebuttonbox" style="margin-top:10px;margin-left:30px;float:left;">
                    <a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a>
                    <a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a>
                    <a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a>
                    <a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a>
                    <a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a>
                    <a href="#" class="bds_more" data-cmd="more"></a>
                </div>
                <script>
                    window._bd_share_config = {
                        "common": {
                            "bdSnsKey": {},
                            "bdText": "",
                            "bdMini": "1",
                            "bdMiniList": false,
                            "bdStyle": "2",
                            "bdSize": "16"
                        },
                        "share": {}
                    };
                    with(document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];
                </script>
                
                    
                        
<nav id="article-nav">
  
    <a href="/2016/12/07/浅谈JVM垃圾收集器/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          浅谈JVM垃圾收集器
        
      </div>
    </a>
  
  
    <a href="/2016/11/16/网络带宽瓶颈导致tps上不去/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">网络带宽瓶颈导致tps上不去</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


                            
                                <!-- 多说评论框 start -->
                                
                                    <div class="ds-thread" data-thread-key="post-浅析jvm内存区域" data-title="浅析JVM内存区域" data-url="http://tonylit.me/2016/11/21/浅析jvm内存区域/"></div>
                                    <!-- 多说评论框 end -->
                                    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
                                    <script type="text/javascript">
                                        var duoshuoQuery = {
                                            short_name: "tonylit"
                                        };
                                        (function() {
                                            var ds = document.createElement('script');
                                            ds.type = 'text/javascript';
                                            ds.async = true;
                                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                                            ds.charset = 'UTF-8';
                                            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
                                        })();
                                    </script>
                                    <!-- 多说公共JS代码 end -->
                                    
</article>

<!--

    <div style="width:100%;background-color:#fff;">
        <div id="uyan_frame" style="margin:auto 10px 10px 10px;"></div>
    </div>
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2017540"></script>
    
-->
<!--

-->

</div>
      <!--<footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 tonyli
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
    
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','ZDWgkzoEyRjqY6u-8gjX','2.0.0');
</script>
   
  </div>
</footer>-->
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
<script src="/js/prefixfree.js" type="text/javascript"></script>
<script src="/js/require-2.1.20.js" type="text/javascript"></script>
<script src="/js/jquery-1.9.1.min.js" type="text/javascript"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;z-index:9999;opacity: 100%;">
    <a title="返回顶部" style="opacity: 100%;">
        <img src="/img/scrollup.png" />
    </a>
</div>

<script src="/js/totop.js"></script>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','ZDWgkzoEyRjqY6u-8gjX','2.0.0');
</script>

  </div>
</body>
</html>
